// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_FB_SENSOR_MSGS_H_
#define FLATBUFFERS_GENERATED_SCHEMA_FB_SENSOR_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace fb {

struct MsgMetadata;
struct MsgMetadataBuilder;
struct MsgMetadataT;

struct MsgWithMetadata;
struct MsgWithMetadataBuilder;
struct MsgWithMetadataT;

struct RosTime;

struct RosDuration;

namespace amrl_msgs {

struct RobofleetStatus;
struct RobofleetStatusBuilder;
struct RobofleetStatusT;

}  // namespace amrl_msgs

namespace std_msgs {

struct Header;
struct HeaderBuilder;
struct HeaderT;

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatus;
struct NavSatStatusBuilder;
struct NavSatStatusT;

struct NavSatFix;
struct NavSatFixBuilder;
struct NavSatFixT;

namespace NavSatStatusConstants {

enum status_no_fix {
  status_no_fix_value = -1,
  status_no_fix_MIN = status_no_fix_value,
  status_no_fix_MAX = status_no_fix_value
};

inline const status_no_fix (&EnumValuesstatus_no_fix())[1] {
  static const status_no_fix values[] = {
    status_no_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_no_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_no_fix(status_no_fix e) {
  if (flatbuffers::IsOutRange(e, status_no_fix_value, status_no_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_no_fix_value);
  return EnumNamesstatus_no_fix()[index];
}

enum status_fix {
  status_fix_value = 0,
  status_fix_MIN = status_fix_value,
  status_fix_MAX = status_fix_value
};

inline const status_fix (&EnumValuesstatus_fix())[1] {
  static const status_fix values[] = {
    status_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_fix(status_fix e) {
  if (flatbuffers::IsOutRange(e, status_fix_value, status_fix_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesstatus_fix()[index];
}

enum status_sbas_fix {
  status_sbas_fix_value = 1,
  status_sbas_fix_MIN = status_sbas_fix_value,
  status_sbas_fix_MAX = status_sbas_fix_value
};

inline const status_sbas_fix (&EnumValuesstatus_sbas_fix())[1] {
  static const status_sbas_fix values[] = {
    status_sbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_sbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_sbas_fix(status_sbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_sbas_fix_value, status_sbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_sbas_fix_value);
  return EnumNamesstatus_sbas_fix()[index];
}

enum status_gbas_fix {
  status_gbas_fix_value = 2,
  status_gbas_fix_MIN = status_gbas_fix_value,
  status_gbas_fix_MAX = status_gbas_fix_value
};

inline const status_gbas_fix (&EnumValuesstatus_gbas_fix())[1] {
  static const status_gbas_fix values[] = {
    status_gbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_gbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_gbas_fix(status_gbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_gbas_fix_value, status_gbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_gbas_fix_value);
  return EnumNamesstatus_gbas_fix()[index];
}

enum service_gps {
  service_gps_value = 1,
  service_gps_MIN = service_gps_value,
  service_gps_MAX = service_gps_value
};

inline const service_gps (&EnumValuesservice_gps())[1] {
  static const service_gps values[] = {
    service_gps_value
  };
  return values;
}

inline const char * const *EnumNamesservice_gps() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_gps(service_gps e) {
  if (flatbuffers::IsOutRange(e, service_gps_value, service_gps_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_gps_value);
  return EnumNamesservice_gps()[index];
}

enum service_glonass {
  service_glonass_value = 2,
  service_glonass_MIN = service_glonass_value,
  service_glonass_MAX = service_glonass_value
};

inline const service_glonass (&EnumValuesservice_glonass())[1] {
  static const service_glonass values[] = {
    service_glonass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_glonass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_glonass(service_glonass e) {
  if (flatbuffers::IsOutRange(e, service_glonass_value, service_glonass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_glonass_value);
  return EnumNamesservice_glonass()[index];
}

enum service_compass {
  service_compass_value = 4,
  service_compass_MIN = service_compass_value,
  service_compass_MAX = service_compass_value
};

inline const service_compass (&EnumValuesservice_compass())[1] {
  static const service_compass values[] = {
    service_compass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_compass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_compass(service_compass e) {
  if (flatbuffers::IsOutRange(e, service_compass_value, service_compass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_compass_value);
  return EnumNamesservice_compass()[index];
}

enum service_galileo {
  service_galileo_value = 8,
  service_galileo_MIN = service_galileo_value,
  service_galileo_MAX = service_galileo_value
};

inline const service_galileo (&EnumValuesservice_galileo())[1] {
  static const service_galileo values[] = {
    service_galileo_value
  };
  return values;
}

inline const char * const *EnumNamesservice_galileo() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_galileo(service_galileo e) {
  if (flatbuffers::IsOutRange(e, service_galileo_value, service_galileo_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_galileo_value);
  return EnumNamesservice_galileo()[index];
}

}  // namespace NavSatStatusConstants

namespace NavSatFixConstants {

enum covariance_type_unknown {
  covariance_type_unknown_value = 0,
  covariance_type_unknown_MIN = covariance_type_unknown_value,
  covariance_type_unknown_MAX = covariance_type_unknown_value
};

inline const covariance_type_unknown (&EnumValuescovariance_type_unknown())[1] {
  static const covariance_type_unknown values[] = {
    covariance_type_unknown_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_unknown() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_unknown(covariance_type_unknown e) {
  if (flatbuffers::IsOutRange(e, covariance_type_unknown_value, covariance_type_unknown_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamescovariance_type_unknown()[index];
}

enum covariance_type_approximated {
  covariance_type_approximated_value = 1,
  covariance_type_approximated_MIN = covariance_type_approximated_value,
  covariance_type_approximated_MAX = covariance_type_approximated_value
};

inline const covariance_type_approximated (&EnumValuescovariance_type_approximated())[1] {
  static const covariance_type_approximated values[] = {
    covariance_type_approximated_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_approximated() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_approximated(covariance_type_approximated e) {
  if (flatbuffers::IsOutRange(e, covariance_type_approximated_value, covariance_type_approximated_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_approximated_value);
  return EnumNamescovariance_type_approximated()[index];
}

enum covariance_type_diagonal_known {
  covariance_type_diagonal_known_value = 2,
  covariance_type_diagonal_known_MIN = covariance_type_diagonal_known_value,
  covariance_type_diagonal_known_MAX = covariance_type_diagonal_known_value
};

inline const covariance_type_diagonal_known (&EnumValuescovariance_type_diagonal_known())[1] {
  static const covariance_type_diagonal_known values[] = {
    covariance_type_diagonal_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_diagonal_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_diagonal_known(covariance_type_diagonal_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_diagonal_known_value, covariance_type_diagonal_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_diagonal_known_value);
  return EnumNamescovariance_type_diagonal_known()[index];
}

enum covariance_type_known {
  covariance_type_known_value = 3,
  covariance_type_known_MIN = covariance_type_known_value,
  covariance_type_known_MAX = covariance_type_known_value
};

inline const covariance_type_known (&EnumValuescovariance_type_known())[1] {
  static const covariance_type_known values[] = {
    covariance_type_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_known(covariance_type_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_known_value, covariance_type_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_known_value);
  return EnumNamescovariance_type_known()[index];
}

}  // namespace NavSatFixConstants
}  // namespace sensor_msgs

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t secs_;
  uint32_t nsecs_;

 public:
  RosTime() {
    memset(static_cast<void *>(this), 0, sizeof(RosTime));
  }
  RosTime(uint32_t _secs, uint32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  uint32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  uint32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosTime, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosDuration FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t secs_;
  int32_t nsecs_;

 public:
  RosDuration() {
    memset(static_cast<void *>(this), 0, sizeof(RosDuration));
  }
  RosDuration(int32_t _secs, int32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  int32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  int32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosDuration, 8);

struct MsgMetadataT : public flatbuffers::NativeTable {
  typedef MsgMetadata TableType;
  std::string topic;
  MsgMetadataT() {
  }
};

struct MsgMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgMetadataT NativeTableType;
  typedef MsgMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC = 4
  };
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
  MsgMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgMetadataBuilder {
  typedef MsgMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(MsgMetadata::VT_TOPIC, topic);
  }
  explicit MsgMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MsgMetadataBuilder &operator=(const MsgMetadataBuilder &);
  flatbuffers::Offset<MsgMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  MsgMetadataBuilder builder_(_fbb);
  builder_.add_topic(topic);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *topic = nullptr) {
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return fb::CreateMsgMetadata(
      _fbb,
      topic__);
}

flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgWithMetadataT : public flatbuffers::NativeTable {
  typedef MsgWithMetadata TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  MsgWithMetadataT() {
  }
};

struct MsgWithMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgWithMetadataT NativeTableType;
  typedef MsgWithMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  MsgWithMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgWithMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgWithMetadataBuilder {
  typedef MsgWithMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MsgWithMetadata::VT___METADATA, __metadata);
  }
  explicit MsgWithMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MsgWithMetadataBuilder &operator=(const MsgWithMetadataBuilder &);
  flatbuffers::Offset<MsgWithMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgWithMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  MsgWithMetadataBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace amrl_msgs {

struct RobofleetStatusT : public flatbuffers::NativeTable {
  typedef RobofleetStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string status;
  float battery_level;
  std::string location;
  RobofleetStatusT()
      : battery_level(0.0f) {
  }
};

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetStatusT NativeTableType;
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_BATTERY_LEVEL = 8,
    VT_LOCATION = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
  RobofleetStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RobofleetStatusBuilder &operator=(const RobofleetStatusBuilder &);
  flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    float battery_level = 0.0f,
    flatbuffers::Offset<flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      battery_level,
      location__);
}

flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace amrl_msgs

namespace std_msgs {

struct HeaderT : public flatbuffers::NativeTable {
  typedef Header TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint32_t seq;
  std::unique_ptr<fb::RosTime> stamp;
  std::string frame_id;
  HeaderT()
      : seq(0) {
  }
};

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ) &&
           VerifyField<fb::RosTime>(verifier, VT_STAMP) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Header> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderBuilder &operator=(const HeaderBuilder &);
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Header> CreateHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatusT : public flatbuffers::NativeTable {
  typedef NavSatStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  int8_t status;
  uint16_t service;
  NavSatStatusT()
      : status(0),
        service(0) {
  }
};

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatStatusT NativeTableType;
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE) &&
           verifier.EndTable();
  }
  NavSatStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NavSatStatusBuilder &operator=(const NavSatStatusBuilder &);
  flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatFixT : public flatbuffers::NativeTable {
  typedef NavSatFix TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> status;
  double latitude;
  double longitude;
  double altitude;
  std::vector<double> position_covariance;
  uint8_t position_covariance_type;
  NavSatFixT()
      : latitude(0.0),
        longitude(0.0),
        altitude(0.0),
        position_covariance_type(0) {
  }
};

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatFixT NativeTableType;
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_ALTITUDE) &&
           VerifyOffset(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE) &&
           verifier.EndTable();
  }
  NavSatFixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatFix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NavSatFixBuilder &operator=(const NavSatFixBuilder &);
  flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatFix>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace sensor_msgs

inline MsgMetadataT *MsgMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgMetadataT> _o = std::unique_ptr<fb::MsgMetadataT>(new MsgMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgMetadata::UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = topic(); if (_e) _o->topic = _e->str(); }
}

inline flatbuffers::Offset<MsgMetadata> MsgMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _topic = _o->topic.empty() ? 0 : _fbb.CreateString(_o->topic);
  return fb::CreateMsgMetadata(
      _fbb,
      _topic);
}

inline MsgWithMetadataT *MsgWithMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgWithMetadataT> _o = std::unique_ptr<fb::MsgWithMetadataT>(new MsgWithMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgWithMetadata::UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<MsgWithMetadata> MsgWithMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgWithMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgWithMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::CreateMsgWithMetadata(
      _fbb,
      ___metadata);
}

namespace amrl_msgs {

inline RobofleetStatusT *RobofleetStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetStatusT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetStatusT>(new RobofleetStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetStatus::UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = battery_level(); _o->battery_level = _e; }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
}

inline flatbuffers::Offset<RobofleetStatus> RobofleetStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _battery_level = _o->battery_level;
  auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      ___metadata,
      _status,
      _battery_level,
      _location);
}

}  // namespace amrl_msgs

namespace std_msgs {

inline HeaderT *Header::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::HeaderT> _o = std::unique_ptr<fb::std_msgs::HeaderT>(new HeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline flatbuffers::Offset<Header> Header::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _seq = _o->seq;
  auto _stamp = _o->stamp ? _o->stamp.get() : 0;
  auto _frame_id = _o->frame_id.empty() ? 0 : _fbb.CreateString(_o->frame_id);
  return fb::std_msgs::CreateHeader(
      _fbb,
      ___metadata,
      _seq,
      _stamp,
      _frame_id);
}

}  // namespace std_msgs

namespace sensor_msgs {

inline NavSatStatusT *NavSatStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> _o = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(new NavSatStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatStatus::UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); _o->status = _e; }
  { auto _e = service(); _o->service = _e; }
}

inline flatbuffers::Offset<NavSatStatus> NavSatStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _service = _o->service;
  return fb::sensor_msgs::CreateNavSatStatus(
      _fbb,
      ___metadata,
      _status,
      _service);
}

inline NavSatFixT *NavSatFix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatFixT> _o = std::unique_ptr<fb::sensor_msgs::NavSatFixT>(new NavSatFixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatFix::UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(_e->UnPack(_resolver)); }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = position_covariance(); if (_e) { _o->position_covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position_covariance[_i] = _e->Get(_i); } } }
  { auto _e = position_covariance_type(); _o->position_covariance_type = _e; }
}

inline flatbuffers::Offset<NavSatFix> NavSatFix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatFix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatFixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateNavSatStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  auto _position_covariance = _o->position_covariance.size() ? _fbb.CreateVector(_o->position_covariance) : 0;
  auto _position_covariance_type = _o->position_covariance_type;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      ___metadata,
      _header,
      _status,
      _latitude,
      _longitude,
      _altitude,
      _position_covariance,
      _position_covariance_type);
}

}  // namespace sensor_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SCHEMA_FB_SENSOR_MSGS_H_
