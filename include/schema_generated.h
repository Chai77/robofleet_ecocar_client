// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_
#define FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace fb {

struct MsgMetadata;
struct MsgMetadataBuilder;
struct MsgMetadataT;

struct MsgWithMetadata;
struct MsgWithMetadataBuilder;
struct MsgWithMetadataT;

struct RosTime;

struct RosDuration;

namespace amrl_msgs {

struct RobofleetStatus;
struct RobofleetStatusBuilder;
struct RobofleetStatusT;

}  // namespace amrl_msgs

namespace std_msgs {

struct Header;
struct HeaderBuilder;
struct HeaderT;

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatus;
struct NavSatStatusBuilder;
struct NavSatStatusT;

struct NavSatFix;
struct NavSatFixBuilder;
struct NavSatFixT;

}  // namespace sensor_msgs

namespace geometry_msgs {

struct Point;
struct PointBuilder;
struct PointT;

struct Quaternion;
struct QuaternionBuilder;
struct QuaternionT;

struct Pose;
struct PoseBuilder;
struct PoseT;

struct PoseWithCovariance;
struct PoseWithCovarianceBuilder;
struct PoseWithCovarianceT;

struct Vector3;
struct Vector3Builder;
struct Vector3T;

struct Twist;
struct TwistBuilder;
struct TwistT;

struct TwistWithCovariance;
struct TwistWithCovarianceBuilder;
struct TwistWithCovarianceT;

}  // namespace geometry_msgs

namespace nav_msgs {

struct Odometry;
struct OdometryBuilder;
struct OdometryT;

}  // namespace nav_msgs

namespace sensor_msgs {
namespace NavSatStatusConstants {

enum status_no_fix {
  status_no_fix_value = -1,
  status_no_fix_MIN = status_no_fix_value,
  status_no_fix_MAX = status_no_fix_value
};

inline const status_no_fix (&EnumValuesstatus_no_fix())[1] {
  static const status_no_fix values[] = {
    status_no_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_no_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_no_fix(status_no_fix e) {
  if (flatbuffers::IsOutRange(e, status_no_fix_value, status_no_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_no_fix_value);
  return EnumNamesstatus_no_fix()[index];
}

enum status_fix {
  status_fix_value = 0,
  status_fix_MIN = status_fix_value,
  status_fix_MAX = status_fix_value
};

inline const status_fix (&EnumValuesstatus_fix())[1] {
  static const status_fix values[] = {
    status_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_fix(status_fix e) {
  if (flatbuffers::IsOutRange(e, status_fix_value, status_fix_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesstatus_fix()[index];
}

enum status_sbas_fix {
  status_sbas_fix_value = 1,
  status_sbas_fix_MIN = status_sbas_fix_value,
  status_sbas_fix_MAX = status_sbas_fix_value
};

inline const status_sbas_fix (&EnumValuesstatus_sbas_fix())[1] {
  static const status_sbas_fix values[] = {
    status_sbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_sbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_sbas_fix(status_sbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_sbas_fix_value, status_sbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_sbas_fix_value);
  return EnumNamesstatus_sbas_fix()[index];
}

enum status_gbas_fix {
  status_gbas_fix_value = 2,
  status_gbas_fix_MIN = status_gbas_fix_value,
  status_gbas_fix_MAX = status_gbas_fix_value
};

inline const status_gbas_fix (&EnumValuesstatus_gbas_fix())[1] {
  static const status_gbas_fix values[] = {
    status_gbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_gbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_gbas_fix(status_gbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_gbas_fix_value, status_gbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_gbas_fix_value);
  return EnumNamesstatus_gbas_fix()[index];
}

enum service_gps {
  service_gps_value = 1,
  service_gps_MIN = service_gps_value,
  service_gps_MAX = service_gps_value
};

inline const service_gps (&EnumValuesservice_gps())[1] {
  static const service_gps values[] = {
    service_gps_value
  };
  return values;
}

inline const char * const *EnumNamesservice_gps() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_gps(service_gps e) {
  if (flatbuffers::IsOutRange(e, service_gps_value, service_gps_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_gps_value);
  return EnumNamesservice_gps()[index];
}

enum service_glonass {
  service_glonass_value = 2,
  service_glonass_MIN = service_glonass_value,
  service_glonass_MAX = service_glonass_value
};

inline const service_glonass (&EnumValuesservice_glonass())[1] {
  static const service_glonass values[] = {
    service_glonass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_glonass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_glonass(service_glonass e) {
  if (flatbuffers::IsOutRange(e, service_glonass_value, service_glonass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_glonass_value);
  return EnumNamesservice_glonass()[index];
}

enum service_compass {
  service_compass_value = 4,
  service_compass_MIN = service_compass_value,
  service_compass_MAX = service_compass_value
};

inline const service_compass (&EnumValuesservice_compass())[1] {
  static const service_compass values[] = {
    service_compass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_compass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_compass(service_compass e) {
  if (flatbuffers::IsOutRange(e, service_compass_value, service_compass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_compass_value);
  return EnumNamesservice_compass()[index];
}

enum service_galileo {
  service_galileo_value = 8,
  service_galileo_MIN = service_galileo_value,
  service_galileo_MAX = service_galileo_value
};

inline const service_galileo (&EnumValuesservice_galileo())[1] {
  static const service_galileo values[] = {
    service_galileo_value
  };
  return values;
}

inline const char * const *EnumNamesservice_galileo() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_galileo(service_galileo e) {
  if (flatbuffers::IsOutRange(e, service_galileo_value, service_galileo_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_galileo_value);
  return EnumNamesservice_galileo()[index];
}

}  // namespace NavSatStatusConstants

namespace NavSatFixConstants {

enum covariance_type_unknown {
  covariance_type_unknown_value = 0,
  covariance_type_unknown_MIN = covariance_type_unknown_value,
  covariance_type_unknown_MAX = covariance_type_unknown_value
};

inline const covariance_type_unknown (&EnumValuescovariance_type_unknown())[1] {
  static const covariance_type_unknown values[] = {
    covariance_type_unknown_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_unknown() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_unknown(covariance_type_unknown e) {
  if (flatbuffers::IsOutRange(e, covariance_type_unknown_value, covariance_type_unknown_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamescovariance_type_unknown()[index];
}

enum covariance_type_approximated {
  covariance_type_approximated_value = 1,
  covariance_type_approximated_MIN = covariance_type_approximated_value,
  covariance_type_approximated_MAX = covariance_type_approximated_value
};

inline const covariance_type_approximated (&EnumValuescovariance_type_approximated())[1] {
  static const covariance_type_approximated values[] = {
    covariance_type_approximated_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_approximated() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_approximated(covariance_type_approximated e) {
  if (flatbuffers::IsOutRange(e, covariance_type_approximated_value, covariance_type_approximated_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_approximated_value);
  return EnumNamescovariance_type_approximated()[index];
}

enum covariance_type_diagonal_known {
  covariance_type_diagonal_known_value = 2,
  covariance_type_diagonal_known_MIN = covariance_type_diagonal_known_value,
  covariance_type_diagonal_known_MAX = covariance_type_diagonal_known_value
};

inline const covariance_type_diagonal_known (&EnumValuescovariance_type_diagonal_known())[1] {
  static const covariance_type_diagonal_known values[] = {
    covariance_type_diagonal_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_diagonal_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_diagonal_known(covariance_type_diagonal_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_diagonal_known_value, covariance_type_diagonal_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_diagonal_known_value);
  return EnumNamescovariance_type_diagonal_known()[index];
}

enum covariance_type_known {
  covariance_type_known_value = 3,
  covariance_type_known_MIN = covariance_type_known_value,
  covariance_type_known_MAX = covariance_type_known_value
};

inline const covariance_type_known (&EnumValuescovariance_type_known())[1] {
  static const covariance_type_known values[] = {
    covariance_type_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_known(covariance_type_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_known_value, covariance_type_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_known_value);
  return EnumNamescovariance_type_known()[index];
}

}  // namespace NavSatFixConstants
}  // namespace sensor_msgs

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t secs_;
  uint32_t nsecs_;

 public:
  RosTime() {
    memset(static_cast<void *>(this), 0, sizeof(RosTime));
  }
  RosTime(uint32_t _secs, uint32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  uint32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  uint32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosTime, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosDuration FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t secs_;
  int32_t nsecs_;

 public:
  RosDuration() {
    memset(static_cast<void *>(this), 0, sizeof(RosDuration));
  }
  RosDuration(int32_t _secs, int32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  int32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  int32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosDuration, 8);

struct MsgMetadataT : public flatbuffers::NativeTable {
  typedef MsgMetadata TableType;
  std::string type;
  std::string topic;
  MsgMetadataT() {
  }
};

struct MsgMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgMetadataT NativeTableType;
  typedef MsgMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TOPIC = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
  MsgMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgMetadataBuilder {
  typedef MsgMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(MsgMetadata::VT_TYPE, type);
  }
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(MsgMetadata::VT_TOPIC, topic);
  }
  explicit MsgMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MsgMetadataBuilder &operator=(const MsgMetadataBuilder &);
  flatbuffers::Offset<MsgMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  MsgMetadataBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *topic = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return fb::CreateMsgMetadata(
      _fbb,
      type__,
      topic__);
}

flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgWithMetadataT : public flatbuffers::NativeTable {
  typedef MsgWithMetadata TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  MsgWithMetadataT() {
  }
};

struct MsgWithMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgWithMetadataT NativeTableType;
  typedef MsgWithMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  MsgWithMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgWithMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgWithMetadataBuilder {
  typedef MsgWithMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MsgWithMetadata::VT___METADATA, __metadata);
  }
  explicit MsgWithMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MsgWithMetadataBuilder &operator=(const MsgWithMetadataBuilder &);
  flatbuffers::Offset<MsgWithMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgWithMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  MsgWithMetadataBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace amrl_msgs {

struct RobofleetStatusT : public flatbuffers::NativeTable {
  typedef RobofleetStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string status;
  bool is_ok;
  float battery_level;
  std::string location;
  RobofleetStatusT()
      : is_ok(false),
        battery_level(0.0f) {
  }
};

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetStatusT NativeTableType;
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_IS_OK = 8,
    VT_BATTERY_LEVEL = 10,
    VT_LOCATION = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  bool is_ok() const {
    return GetField<uint8_t>(VT_IS_OK, 0) != 0;
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint8_t>(verifier, VT_IS_OK) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
  RobofleetStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_is_ok(bool is_ok) {
    fbb_.AddElement<uint8_t>(RobofleetStatus::VT_IS_OK, static_cast<uint8_t>(is_ok), 0);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RobofleetStatusBuilder &operator=(const RobofleetStatusBuilder &);
  flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    bool is_ok = false,
    float battery_level = 0.0f,
    flatbuffers::Offset<flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_is_ok(is_ok);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    bool is_ok = false,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      is_ok,
      battery_level,
      location__);
}

flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace amrl_msgs

namespace std_msgs {

struct HeaderT : public flatbuffers::NativeTable {
  typedef Header TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint32_t seq;
  std::unique_ptr<fb::RosTime> stamp;
  std::string frame_id;
  HeaderT()
      : seq(0) {
  }
};

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ) &&
           VerifyField<fb::RosTime>(verifier, VT_STAMP) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Header> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderBuilder &operator=(const HeaderBuilder &);
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Header> CreateHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatusT : public flatbuffers::NativeTable {
  typedef NavSatStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  int8_t status;
  uint16_t service;
  NavSatStatusT()
      : status(0),
        service(0) {
  }
};

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatStatusT NativeTableType;
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE) &&
           verifier.EndTable();
  }
  NavSatStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NavSatStatusBuilder &operator=(const NavSatStatusBuilder &);
  flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatFixT : public flatbuffers::NativeTable {
  typedef NavSatFix TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> status;
  double latitude;
  double longitude;
  double altitude;
  std::vector<double> position_covariance;
  uint8_t position_covariance_type;
  NavSatFixT()
      : latitude(0.0),
        longitude(0.0),
        altitude(0.0),
        position_covariance_type(0) {
  }
};

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatFixT NativeTableType;
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_ALTITUDE) &&
           VerifyOffset(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE) &&
           verifier.EndTable();
  }
  NavSatFixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatFix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NavSatFixBuilder &operator=(const NavSatFixBuilder &);
  flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatFix>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace sensor_msgs

namespace geometry_msgs {

struct PointT : public flatbuffers::NativeTable {
  typedef Point TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  PointT()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Point FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointT NativeTableType;
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  PointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Point> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointBuilder {
  typedef Point Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointBuilder &operator=(const PointBuilder &);
  flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point> CreatePoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionT : public flatbuffers::NativeTable {
  typedef Quaternion TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  double w;
  QuaternionT()
      : x(0.0),
        y(0.0),
        z(0.0),
        w(0.0) {
  }
};

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionT NativeTableType;
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_W = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           VerifyField<double>(verifier, VT_W) &&
           verifier.EndTable();
  }
  QuaternionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Quaternion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Quaternion::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseT : public flatbuffers::NativeTable {
  typedef Pose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PointT> position;
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation;
  PoseT() {
  }
};

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseT NativeTableType;
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  PoseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseBuilder {
  typedef Pose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseBuilder &operator=(const PoseBuilder &);
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceT : public flatbuffers::NativeTable {
  typedef PoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  std::vector<double> covariance;
  PoseWithCovarianceT() {
  }
};

struct PoseWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseWithCovarianceT NativeTableType;
  typedef PoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffset(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceBuilder {
  typedef PoseWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(PoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit PoseWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseWithCovarianceBuilder &operator=(const PoseWithCovarianceBuilder &);
  flatbuffers::Offset<PoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseWithCovariance>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  PoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vector3T : public flatbuffers::NativeTable {
  typedef Vector3 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  Vector3T()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vector3T NativeTableType;
  typedef Vector3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  Vector3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vector3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3Builder {
  typedef Vector3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 0.0);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vector3Builder &operator=(const Vector3Builder &);
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistT : public flatbuffers::NativeTable {
  typedef Twist TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear;
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular;
  TwistT() {
  }
};

struct Twist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistT NativeTableType;
  typedef TwistBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffset(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
  TwistT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Twist> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistBuilder {
  typedef Twist Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Twist::VT___METADATA, __metadata);
  }
  void add_linear(flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Twist::VT_LINEAR, linear);
  }
  void add_angular(flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Twist::VT_ANGULAR, angular);
  }
  explicit TwistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TwistBuilder &operator=(const TwistBuilder &);
  flatbuffers::Offset<Twist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Twist>(end);
    return o;
  }
};

inline flatbuffers::Offset<Twist> CreateTwist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  TwistBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistWithCovarianceT : public flatbuffers::NativeTable {
  typedef TwistWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::TwistT> twist;
  std::vector<double> covariance;
  TwistWithCovarianceT() {
  }
};

struct TwistWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistWithCovarianceT NativeTableType;
  typedef TwistWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TWIST = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           VerifyOffset(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TwistWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TwistWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistWithCovarianceBuilder {
  typedef TwistWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovariance::VT___METADATA, __metadata);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistWithCovariance::VT_TWIST, twist);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(TwistWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit TwistWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TwistWithCovarianceBuilder &operator=(const TwistWithCovarianceBuilder &);
  flatbuffers::Offset<TwistWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TwistWithCovariance>(end);
    return o;
  }
};

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  TwistWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_twist(twist);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      __metadata,
      twist,
      covariance__);
}

flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace geometry_msgs

namespace nav_msgs {

struct OdometryT : public flatbuffers::NativeTable {
  typedef Odometry TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string child_frame_id;
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose;
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> twist;
  OdometryT() {
  }
};

struct Odometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OdometryT NativeTableType;
  typedef OdometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_POSE = 10,
    VT_TWIST = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *child_frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffset(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  OdometryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Odometry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OdometryBuilder {
  typedef Odometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Odometry::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Odometry::VT_HEADER, header);
  }
  void add_child_frame_id(flatbuffers::Offset<flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(Odometry::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(Odometry::VT_POSE, pose);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(Odometry::VT_TWIST, twist);
  }
  explicit OdometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OdometryBuilder &operator=(const OdometryBuilder &);
  flatbuffers::Offset<Odometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Odometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<Odometry> CreateOdometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> child_frame_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  OdometryBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_pose(pose);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Odometry> CreateOdometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      pose,
      twist);
}

flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace nav_msgs

inline MsgMetadataT *MsgMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgMetadataT> _o = std::unique_ptr<fb::MsgMetadataT>(new MsgMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgMetadata::UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = topic(); if (_e) _o->topic = _e->str(); }
}

inline flatbuffers::Offset<MsgMetadata> MsgMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _topic = _o->topic.empty() ? 0 : _fbb.CreateString(_o->topic);
  return fb::CreateMsgMetadata(
      _fbb,
      _type,
      _topic);
}

inline MsgWithMetadataT *MsgWithMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgWithMetadataT> _o = std::unique_ptr<fb::MsgWithMetadataT>(new MsgWithMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgWithMetadata::UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<MsgWithMetadata> MsgWithMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgWithMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgWithMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::CreateMsgWithMetadata(
      _fbb,
      ___metadata);
}

namespace amrl_msgs {

inline RobofleetStatusT *RobofleetStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetStatusT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetStatusT>(new RobofleetStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetStatus::UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = is_ok(); _o->is_ok = _e; }
  { auto _e = battery_level(); _o->battery_level = _e; }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
}

inline flatbuffers::Offset<RobofleetStatus> RobofleetStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _is_ok = _o->is_ok;
  auto _battery_level = _o->battery_level;
  auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      ___metadata,
      _status,
      _is_ok,
      _battery_level,
      _location);
}

}  // namespace amrl_msgs

namespace std_msgs {

inline HeaderT *Header::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::HeaderT> _o = std::unique_ptr<fb::std_msgs::HeaderT>(new HeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline flatbuffers::Offset<Header> Header::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _seq = _o->seq;
  auto _stamp = _o->stamp ? _o->stamp.get() : 0;
  auto _frame_id = _o->frame_id.empty() ? 0 : _fbb.CreateString(_o->frame_id);
  return fb::std_msgs::CreateHeader(
      _fbb,
      ___metadata,
      _seq,
      _stamp,
      _frame_id);
}

}  // namespace std_msgs

namespace sensor_msgs {

inline NavSatStatusT *NavSatStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> _o = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(new NavSatStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatStatus::UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); _o->status = _e; }
  { auto _e = service(); _o->service = _e; }
}

inline flatbuffers::Offset<NavSatStatus> NavSatStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _service = _o->service;
  return fb::sensor_msgs::CreateNavSatStatus(
      _fbb,
      ___metadata,
      _status,
      _service);
}

inline NavSatFixT *NavSatFix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatFixT> _o = std::unique_ptr<fb::sensor_msgs::NavSatFixT>(new NavSatFixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatFix::UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(_e->UnPack(_resolver)); }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = position_covariance(); if (_e) { _o->position_covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position_covariance[_i] = _e->Get(_i); } } }
  { auto _e = position_covariance_type(); _o->position_covariance_type = _e; }
}

inline flatbuffers::Offset<NavSatFix> NavSatFix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatFix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatFixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateNavSatStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  auto _position_covariance = _o->position_covariance.size() ? _fbb.CreateVector(_o->position_covariance) : 0;
  auto _position_covariance_type = _o->position_covariance_type;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      ___metadata,
      _header,
      _status,
      _latitude,
      _longitude,
      _altitude,
      _position_covariance,
      _position_covariance_type);
}

}  // namespace sensor_msgs

namespace geometry_msgs {

inline PointT *Point::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PointT> _o = std::unique_ptr<fb::geometry_msgs::PointT>(new PointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point::UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Point> Point::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreatePoint(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline QuaternionT *Quaternion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::QuaternionT> _o = std::unique_ptr<fb::geometry_msgs::QuaternionT>(new QuaternionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quaternion::UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline flatbuffers::Offset<Quaternion> Quaternion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuaternion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuaternionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return fb::geometry_msgs::CreateQuaternion(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z,
      _w);
}

inline PoseT *Pose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseT> _o = std::unique_ptr<fb::geometry_msgs::PoseT>(new PoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose::UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Pose> Pose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline PoseWithCovarianceT *PoseWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(new PoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovariance::UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PoseWithCovariance> PoseWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _o->covariance.size() ? _fbb.CreateVector(_o->covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline Vector3T *Vector3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::Vector3T> _o = std::unique_ptr<fb::geometry_msgs::Vector3T>(new Vector3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3::UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Vector3> Vector3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVector3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vector3T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreateVector3(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline TwistT *Twist::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistT> _o = std::unique_ptr<fb::geometry_msgs::TwistT>(new TwistT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Twist::UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = linear(); if (_e) _o->linear = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
  { auto _e = angular(); if (_e) _o->angular = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Twist> Twist::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwist(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _linear = _o->linear ? CreateVector3(_fbb, _o->linear.get(), _rehasher) : 0;
  auto _angular = _o->angular ? CreateVector3(_fbb, _o->angular.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwist(
      _fbb,
      ___metadata,
      _linear,
      _angular);
}

inline TwistWithCovarianceT *TwistWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(new TwistWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistWithCovariance::UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TwistWithCovariance> TwistWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  auto _covariance = _o->covariance.size() ? _fbb.CreateVector(_o->covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      ___metadata,
      _twist,
      _covariance);
}

}  // namespace geometry_msgs

namespace nav_msgs {

inline OdometryT *Odometry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::nav_msgs::OdometryT> _o = std::unique_ptr<fb::nav_msgs::OdometryT>(new OdometryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Odometry::UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Odometry> Odometry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOdometry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OdometryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _o->child_frame_id.empty() ? 0 : _fbb.CreateString(_o->child_frame_id);
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwistWithCovariance(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _pose,
      _twist);
}

}  // namespace nav_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SCHEMA_FB_NAV_MSGS_H_
